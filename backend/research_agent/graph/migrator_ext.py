"""
Extended Graph Migrator

Research Agent가 수집한 데이터를 Neo4j 그래프에 적재.
기존 GraphMigrator 패턴을 따르되, 동적 노드 라벨/관계 타입을 지원.
"""

import json
import sys
import os

# backend/ 디렉토리를 path에 추가하여 app 모듈 접근 가능
_backend_dir = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
if _backend_dir not in sys.path:
    sys.path.insert(0, _backend_dir)

try:
    from app.neo4j_client import Neo4jClient
except ImportError:
    Neo4jClient = None


class ExtendedMigrator:
    """리서치 데이터를 Neo4j에 동적으로 적재"""

    def __init__(self):
        self._neo4j_available = False
        if Neo4jClient:
            # CLI 직접 실행 시 connect()가 호출되지 않았을 수 있으므로 시도
            if not Neo4jClient.is_available():
                Neo4jClient.connect()
            self._neo4j_available = Neo4jClient.is_available()

    def migrate_research_data(self, data: dict) -> dict:
        """
        리서치 에이전트 출력 데이터를 Neo4j에 적재.

        Args:
            data: {
                "nodes": [{"key": ..., "label": ..., "name": ..., "properties": {...}}, ...],
                "relationships": [{"from_key": ..., "to_key": ..., "type": ..., "properties": {...}}, ...]
            }

        Returns:
            {"nodes_created": int, "relationships_created": int}
        """
        if not self._neo4j_available:
            print("    ⚠ Neo4j not available. Generating Cypher scripts only.")
            return self._generate_cypher_scripts(data)

        nodes_created = 0
        relationships_created = 0

        # 1. 노드 생성 (MERGE로 중복 방지)
        for node in data.get("nodes", []):
            result = self._create_node(node)
            if result:
                nodes_created += result.get("nodes_created", 0)

        # 2. 관계 생성
        for rel in data.get("relationships", []):
            result = self._create_relationship(rel)
            if result:
                relationships_created += result.get("relationships_created", 0)

        return {
            "nodes_created": nodes_created,
            "relationships_created": relationships_created,
        }

    def _create_node(self, node: dict) -> dict:
        """단일 노드 생성 (MERGE)"""
        label = node.get("label", "Unknown")
        key = node.get("key")
        name = node.get("name", key)
        properties = node.get("properties", {})

        # 기본 속성
        props = {"key": key, "name": name}

        # 추가 속성 — Neo4j에 저장 가능한 타입만 필터링
        for k, v in properties.items():
            if isinstance(v, (str, int, float, bool)):
                props[k] = v
            elif isinstance(v, list) and all(isinstance(i, str) for i in v):
                props[k] = v
            elif isinstance(v, (dict, list)):
                # 복합 타입은 JSON 문자열로 변환
                props[k] = json.dumps(v, ensure_ascii=False)

        # 동적 Cypher 생성
        prop_assignments = ", ".join(f"n.{k} = ${k}" for k in props)
        cypher = f"""
        MERGE (n:{label} {{key: $key}})
        ON CREATE SET {prop_assignments}
        ON MATCH SET {prop_assignments}
        """

        return Neo4jClient.run_write(cypher, props)

    def _create_relationship(self, rel: dict) -> dict:
        """단일 관계 생성"""
        from_key = rel.get("from_key")
        to_key = rel.get("to_key")
        rel_type = rel.get("type")
        properties = rel.get("properties", {})

        if not from_key or not to_key or not rel_type:
            return {}

        # 관계 속성
        prop_params = {}
        prop_assignments = ""
        if properties:
            safe_props = {}
            for k, v in properties.items():
                if isinstance(v, (str, int, float, bool)):
                    safe_props[f"rel_{k}"] = v
            if safe_props:
                prop_params = safe_props
                prop_assignments = " {" + ", ".join(f"{k.replace('rel_', '')}: ${k}" for k in safe_props) + "}"

        # 소스/타겟 노드를 라벨 무관하게 key로 검색
        cypher = f"""
        MATCH (a {{key: $from_key}})
        MATCH (b {{key: $to_key}})
        MERGE (a)-[r:{rel_type}{prop_assignments}]->(b)
        """

        params = {"from_key": from_key, "to_key": to_key, **prop_params}
        return Neo4jClient.run_write(cypher, params) or {}

    def _generate_cypher_scripts(self, data: dict) -> dict:
        """
        Neo4j 미연결 시 Cypher 스크립트를 파일로 생성.
        나중에 Neo4j Browser에서 직접 실행 가능.
        """
        from pathlib import Path

        output_dir = Path(__file__).parent.parent / "data" / "cypher"
        output_dir.mkdir(parents=True, exist_ok=True)

        cypher_lines = ["// Auto-generated by Research Agent", "// Execute in Neo4j Browser", ""]

        nodes_count = 0
        rels_count = 0

        # 노드 생성 스크립트
        for node in data.get("nodes", []):
            label = node.get("label", "Unknown")
            key = node.get("key")
            name = node.get("name", key)
            properties = node.get("properties", {})

            props = {"key": key, "name": name}
            for k, v in properties.items():
                if isinstance(v, (str, int, float, bool)):
                    props[k] = v
                elif isinstance(v, list) and all(isinstance(i, str) for i in v):
                    props[k] = v

            props_str = self._format_props_for_cypher(props)
            cypher_lines.append(f"MERGE (n:{label} {{key: '{key}'}})")
            cypher_lines.append(f"ON CREATE SET {props_str};")
            cypher_lines.append("")
            nodes_count += 1

        # 관계 생성 스크립트
        for rel in data.get("relationships", []):
            from_key = rel.get("from_key")
            to_key = rel.get("to_key")
            rel_type = rel.get("type")
            if from_key and to_key and rel_type:
                cypher_lines.append(
                    f"MATCH (a {{key: '{from_key}'}}), (b {{key: '{to_key}'}}) "
                    f"MERGE (a)-[:{rel_type}]->(b);"
                )
                rels_count += 1

        # 파일 저장
        output_file = output_dir / "research_data.cypher"
        output_file.write_text("\n".join(cypher_lines), encoding="utf-8")
        print(f"    Cypher script saved to: {output_file}")
        print(f"    ({nodes_count} nodes, {rels_count} relationships)")

        return {"nodes_created": nodes_count, "relationships_created": rels_count}

    def _format_props_for_cypher(self, props: dict) -> str:
        """딕셔너리를 Cypher SET 절 문자열로 변환"""
        parts = []
        for k, v in props.items():
            if isinstance(v, str):
                escaped = v.replace("'", "\\'")
                parts.append(f"n.{k} = '{escaped}'")
            elif isinstance(v, bool):
                parts.append(f"n.{k} = {'true' if v else 'false'}")
            elif isinstance(v, (int, float)):
                parts.append(f"n.{k} = {v}")
            elif isinstance(v, list):
                list_str = json.dumps(v)
                parts.append(f"n.{k} = {list_str}")
        return ", ".join(parts)


class ResearchGraphQueryService:
    """리서치 데이터에 대한 추가 쿼리 서비스"""

    @staticmethod
    def get_foundry_overview() -> list[dict]:
        """파운드리 기업 + 팹 사이트 + 공정 노드 전체 조회"""
        if not Neo4jClient or not Neo4jClient.is_available():
            return []
        return Neo4jClient.run_query("""
            MATCH (f:Foundry)
            OPTIONAL MATCH (f)-[:OPERATES_FAB]->(fab:FabSite)
            OPTIONAL MATCH (fab)-[:PRODUCES_ON]->(pn:ProcessNode)
            RETURN f.name AS foundry,
                   f.country AS country,
                   f.market_share_pct AS market_share,
                   collect(DISTINCT {fab: fab.name, location: fab.location, status: fab.status}) AS fabs,
                   collect(DISTINCT pn.name) AS process_nodes
            ORDER BY f.market_share_pct DESC
        """)

    @staticmethod
    def get_supply_chain_full_map(accelerator_name: str) -> list[dict]:
        """
        가속기 → 공정 → 파운드리 → 팹 → 장비벤더 → 소재공급사 전체 공급망 맵

        5-hop 이상 관계 탐색
        """
        if not Neo4jClient or not Neo4jClient.is_available():
            return []
        return Neo4jClient.run_query("""
            MATCH (a:AIAccelerator)
            WHERE a.name CONTAINS $name OR a.key CONTAINS $name
            OPTIONAL MATCH (a)-[:MANUFACTURED_ON]->(pn:ProcessNode)
            OPTIONAL MATCH (fab:FabSite)-[:PRODUCES_ON]->(pn)
            OPTIONAL MATCH (f:Foundry)-[:OPERATES_FAB]->(fab)
            OPTIONAL MATCH (c:Company)-[:DESIGNS]->(a)
            OPTIONAL MATCH (a)-[:USES_MEMORY]->(hbm:HBMGeneration)
            OPTIONAL MATCH (ms:MaterialSupplier)-[:SUPPLIES]->(hbm)
            OPTIONAL MATCH (a)-[:USES_INTERCONNECT]->(ic:InterconnectStandard)
            OPTIONAL MATCH (a)-[:OPTIMIZED_FOR]->(app:Application)
            OPTIONAL MATCH (a)-[:COOLED_BY]->(th:ThermalSolution)
            RETURN a.name AS accelerator,
                   c.name AS designer,
                   pn.name AS process_node,
                   f.name AS foundry,
                   collect(DISTINCT fab.name) AS fab_sites,
                   hbm.generation AS hbm_generation,
                   collect(DISTINCT ms.name) AS memory_suppliers,
                   collect(DISTINCT ic.name) AS interconnects,
                   collect(DISTINCT app.name) AS applications,
                   collect(DISTINCT th.name) AS thermal_solutions
        """, {"name": accelerator_name})

    @staticmethod
    def get_regulation_impact(chip_name: str) -> list[dict]:
        """규제가 특정 칩/팹에 미치는 영향 분석"""
        if not Neo4jClient or not Neo4jClient.is_available():
            return []
        return Neo4jClient.run_query("""
            MATCH (r:Regulation)
            OPTIONAL MATCH (r)-[:RESTRICTED_BY|SUBJECT_TO]->(target)
            RETURN r.name AS regulation,
                   r.jurisdiction AS jurisdiction,
                   r.type AS reg_type,
                   r.effective_year AS year,
                   collect(DISTINCT {entity: coalesce(target.name, target.key), label: labels(target)[0]}) AS affected_entities
            ORDER BY r.effective_year DESC
        """)

    @staticmethod
    def get_graph_overview_extended() -> dict:
        """확장된 그래프 통계 (Tier 1/2/3 포함)"""
        if not Neo4jClient or not Neo4jClient.is_available():
            return {"available": False}

        stats = Neo4jClient.get_stats()

        # 새 라벨별 분류
        tier_classification = {
            "existing": ["ProcessNode", "PackagingTech", "HBMGeneration", "AIAccelerator",
                        "AIModel", "Material", "Equipment", "ProcessStep", "DefectType", "EquipmentFailure"],
            "tier1": ["Foundry", "FabSite", "ProcessGeneration", "MemoryStandard", "InterconnectStandard", "SubstrateType"],
            "tier2": ["EquipmentVendor", "EquipmentModel", "MaterialSupplier", "DesignIP", "Company", "Benchmark"],
            "tier3": ["ReliabilityTest", "Standard", "Application", "ThermalSolution", "Regulation", "InspectionMethod"],
        }

        tier_stats = {}
        for tier_name, labels in tier_classification.items():
            count = sum(stats.get("nodes", {}).get(label, 0) for label in labels)
            tier_stats[tier_name] = {"node_count": count, "labels": labels}

        stats["tiers"] = tier_stats
        return stats
